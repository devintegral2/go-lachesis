package main

import (
	"encoding/hex"
	"fmt"
	"os"
	"strconv"
	"strings"

	"github.com/ethereum/go-ethereum/rlp"

	"github.com/Fantom-foundation/go-lachesis/common/bigendian"
	"github.com/Fantom-foundation/go-lachesis/inter"
	"github.com/Fantom-foundation/go-lachesis/inter/idx"
	"github.com/Fantom-foundation/go-lachesis/kvdb"
	"github.com/Fantom-foundation/go-lachesis/kvdb/table"
)

func checkGasRefunds(dbs kvdb.DbProducer) {
	db := dbs.OpenDb("gossip-main")
	defer db.Close()

	// panic: 0: GasPowerLeft(10029560) + GasPowerUsed(70000) != gasPowers.Gas(10164394)
	//                                                                     	10099560 (-64834)
	// event: GasPowerLeft:inter.GasPowerLeft{Gas:[2]uint64{10029560, 0x73834a0}}, GasPowerUsed:70000
	// Checker.CalcGasPower(): calcGasPower(e, selfParent, ctx, ctx.Configs[0](.Idx = 0) )

	// panic(old): gasPower = f( gasPowerAllocatedBn=97094, prevGasPowerLeft=10067300, maxGasPower=14019120 )
	// panic(new): gasPower = f( gasPowerAllocatedBn=69948, prevGasPowerLeft=10067300, maxGasPower=10099560 )

	// panic(old): gasPowerAllocatedBn = f( e.MedianTime=1582804560191889271, prevMedianTime=1582804559776336349, gasPowerPerSec=233652 )
	// panic(new): gasPowerAllocatedBn = f( e.MedianTime=1582804560191889271, prevMedianTime=1582804559776336349, gasPowerPerSec=168326 )

	// panic(old): gasPowerPerSec = f( gas.AllocPerSec=14000000, stake=10000000000, validators.TotalStake=599179430976 )
	// panic(new): gasPowerPerSec = f( gas.AllocPerSec=14000000, stake=11339180800, validators.TotalStake=943097531957 )

	// GasPowerLeft:inter.GasPowerLeft{Gas:[2]uint64{10067300, 0x739b050}}, GasPowerUsed:37600, Lamport:0xfe2
	// GasPowerLeft:inter.GasPowerLeft{Gas:[2]uint64{10067300, 0x739b050}}, GasPowerUsed:37600, Lamport:0xfe2
	/*
		old := pos.Validators{
			values: map[idx.StakerID]pos.Stake{
				0x1:  0x2540be400,
				0x2:  0x2540be400,
				0x3:  0x2540be400,
				0x4:  0x2540be400,
				0x5:  0x2540be400,
				0x6:  0x2540be400,
				0x7:  0x2540be400,
				0x8:  0x2540be400,
				0x9:  0x2540be400,
				0xa:  0x2540be400,
				0xb:  0x2540be400,
				0xc:  0x2540be400, //
				0xd:  0x6c66eaeda,
				0xe:  0xc6b15c165,
				0xf:  0x2aa8e12f2,
				0x10: 0x4389a8be0,
				0x11: 0xc7218830b,
				0x13: 0x25ef9a01d,
				0x14: 0x3d7c91b68,
				0x15: 0x18e1651b89,
				0x16: 0x4fa0b1c68,
				0x17: 0xec8b89a9,
				0x18: 0x1d113d3f7,
				0x19: 0x15fd4a0b8,
				0x1a: 0xe2c727a9,
				0x1b: 0x1b22fce26,
				0x1c: 0x1484f017e5,
				0x1d: 0x1fdfeceaf,
				0x1e: 0x1b32b59f3,
				0x1f: 0x55116702b,
				0x20: 0xbebdb1d5,
			},
			cache: pos.cache{
				indexes: map[idx.StakerID]idx.Validator{
					0x1: 0xb, 0x2: 0xc, 0x3: 0xd, 0x4: 0xe, 0x5: 0xf, 0x6: 0x10, 0x7: 0x11, 0x8: 0x12, 0x9: 0x13, 0xa: 0x14, 0xb: 0x15, 0xc: 0x16, 0xd: 0x4, 0xe: 0x3, 0xf: 0x9, 0x10: 0x7, 0x11: 0x2, 0x13: 0xa, 0x14: 0x8, 0x15: 0x0, 0x16: 0x6, 0x17: 0x1c, 0x18: 0x18, 0x19: 0x1b, 0x1a: 0x1d, 0x1b: 0x1a, 0x1c: 0x1, 0x1d: 0x17, 0x1e: 0x19, 0x1f: 0x5,
					0x20: 0x1e},
				stakes: []pos.Stake{0x18e1651b89, 0x1484f017e5, 0xc7218830b, 0xc6b15c165, 0x6c66eaeda, 0x55116702b, 0x4fa0b1c68, 0x4389a8be0, 0x3d7c91b68, 0x2aa8e12f2, 0x25ef9a01d, 0x2540be400, 0x2540be400, 0x2540be400, 0x2540be400, 0x2540be400, 0x2540be400, 0x2540be400, 0x2540be400, 0x2540be400, 0x2540be400, 0x2540be400, 0x2540be400, 0x1fdfeceaf, 0x1d113d3f7, 0x1b32b59f3, 0x1b22fce26, 0x15fd4a0b8, 0xec8b89a9, 0xe2c727a9,
					0xbebdb1d5},
				ids: []idx.StakerID{0x15, 0x1c, 0x11, 0xe, 0xd, 0x1f, 0x16, 0x10, 0x14, 0xf, 0x13, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc, 0x1d, 0x18, 0x1e, 0x1b, 0x19, 0x17, 0x1a,
					0x20},
				totalStake: 0x8b81e08c40},
		}

		new := pos.Validators{
			values: map[idx.StakerID]pos.Stake{
				0x1:  0x2d90a39b1b,
				0x2:  0x1bbd1b89e9,
				0x3:  0x74322fd8e,
				0x4:  0x4bdd351f1,
				0x5:  0x356e4f4c1,
				0x6:  0x2bc9db111,
				0x7:  0x2c5e7ec2f,
				0x8:  0x2b090c4ec,
				0x9:  0x2a5ba5b96,
				0xa:  0x2c96c4b8f,
				0xb:  0x317f6d460,
				0xc:  0x2a3de2b00, //
				0xd:  0x6c66eaeda,
				0xe:  0xc6b15c165,
				0xf:  0x2aa8e12f2,
				0x10: 0x4389a8be0,
				0x11: 0xc7218830b,
				0x13: 0x25ef9a01d,
				0x14: 0x3d7c91b68,
				0x15: 0x18e1651b89,
				0x16: 0x4fa0b1c68,
				0x17: 0xec8b89a9,
				0x18: 0x1d113d3f7,
				0x19: 0x15fd4a0b8,
				0x1a: 0xe2c727a9,
				0x1b: 0x1b22fce26,
				0x1c: 0x1484f017e5,
				0x1d: 0x1fdfeceaf,
				0x1e: 0x1b32b59f3,
				0x1f: 0x55116702b,
				0x20: 0xbebdb1d5,
			},
			cache: pos.cache{
				indexes: map[idx.StakerID]idx.Validator{
					0x1: 0x0, 0x2: 0x1, 0x3: 0x6, 0x4: 0xa, 0x5: 0xd, 0x6: 0x11, 0x7: 0x10, 0x8: 0x12, 0x9: 0x14, 0xa: 0xf, 0xb: 0xe, 0xc: 0x15, 0xd: 0x7, 0xe: 0x5, 0xf: 0x13, 0x10: 0xb, 0x11: 0x4, 0x13: 0x16, 0x14: 0xc, 0x15: 0x2, 0x16: 0x9, 0x17: 0x1c, 0x18: 0x18, 0x19: 0x1b, 0x1a: 0x1d, 0x1b: 0x1a, 0x1c: 0x3, 0x1d: 0x17, 0x1e: 0x19, 0x1f: 0x8,
					0x20: 0x1e},
				stakes: []pos.Stake{0x2d90a39b1b, 0x1bbd1b89e9, 0x18e1651b89, 0x1484f017e5, 0xc7218830b, 0xc6b15c165, 0x74322fd8e, 0x6c66eaeda, 0x55116702b, 0x4fa0b1c68, 0x4bdd351f1, 0x4389a8be0, 0x3d7c91b68, 0x356e4f4c1, 0x317f6d460, 0x2c96c4b8f, 0x2c5e7ec2f, 0x2bc9db111, 0x2b090c4ec, 0x2aa8e12f2, 0x2a5ba5b96, 0x2a3de2b00, 0x25ef9a01d, 0x1fdfeceaf, 0x1d113d3f7, 0x1b32b59f3, 0x1b22fce26, 0x15fd4a0b8, 0xec8b89a9, 0xe2c727a9,
					0xbebdb1d5},
				ids: []idx.StakerID{0x1, 0x2, 0x15, 0x1c, 0x11, 0xe, 0x3, 0xd, 0x1f, 0x16, 0x4, 0x10, 0x14, 0x5, 0xb, 0xa, 0x7, 0x6, 0x8, 0xf, 0x9, 0xc, 0x13, 0x1d, 0x18, 0x1e, 0x1b, 0x19, 0x17, 0x1a,
					0x20},
				totalStake: 0xdb94fe4e35},
		}
	*/
	// return

	//getEvent(db, "377:1:e53be8")
	//return

	var epoch idx.Epoch = 1

	if len(os.Args) >= 3 {
		x, err := strconv.ParseUint(os.Args[2], 10, 32)
		if err != nil {
			panic(err)
		}
		epoch = idx.Epoch(x)
	}

	tGasPowerRefund := table.New(db, []byte("R"))
	it := tGasPowerRefund.NewIteratorWithPrefix(epoch.Bytes())
	defer it.Release()
	for it.Next() {
		creator := idx.BytesToStakerID(it.Key()[4:])
		gasPower := bigendian.BytesToInt64(it.Value())
		//rr[creator] = gasPower
		fmt.Println(creator, gasPower)
	}

}

// getLastHeaders retrieves all the records about last headers from validators
func getLastHeaders(db kvdb.KeyValueStore, epoch idx.Epoch, creator idx.StakerID) {
	t := table.New(db, []byte("l"))
	it := t.NewIteratorWithPrefix(epoch.Bytes())
	defer it.Release()
	for it.Next() {
		if idx.BytesToStakerID(it.Key()[4:]) != creator {
			continue
		}
		header := &inter.EventHeaderData{}
		err := rlp.DecodeBytes(it.Value(), header)
		if err != nil {
			panic(err)
		}
		fmt.Printf("%#v\n", header)
	}

}

func getEvent(db kvdb.KeyValueStore, id string) {
	t := table.New(db, []byte("e"))
	it := t.NewIteratorWithPrefix(eventShortID2key(id))
	defer it.Release()
	for it.Next() {
		event := &inter.Event{}
		err := rlp.DecodeBytes(it.Value(), event)
		if err != nil {
			panic(err)
		}

		fmt.Printf("%s : %#v\n", id, event)
		fmt.Println(event.GasPowerLeft.String()) // {short=10029560, long=121124000}
	}
}

func eventShortID2key(s string) []byte {
	var (
		x   uint64
		err error

		epoch   idx.Epoch
		lamport idx.Lamport
		tail    []byte
	)

	ss := strings.Split(s, ":")

	x, err = strconv.ParseUint(ss[0], 10, 32)
	if err != nil {
		panic(err)
	}
	epoch = idx.Epoch(x)

	x, err = strconv.ParseUint(ss[1], 10, 32)
	if err != nil {
		panic(err)
	}
	lamport = idx.Lamport(x)

	tail, err = hex.DecodeString(ss[2])
	if err != nil {
		panic(err)
	}

	return append(epoch.Bytes(), append(lamport.Bytes(), tail...)...)
}
